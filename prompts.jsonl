{"report_id": "861940", "title": "OAuth `redirect_uri` bypass using IDN homograph attack resulting in user's access token leakage", "reporter": "yassineaboukir", "company": "Semrush", "status": "Resolved", "vulnerability": {"weakness": "Information Disclosure", "technique": "IDN Homograph Attack", "vector": "OAuth redirect_uri parameter validation bypass"}, "severity": {"initial": "High", "final": "Medium", "cvss_score": 6.4}, "bounty": {"awarded": true, "amount": "Hidden"}, "timeline": [{"date_utc": "2020-04-29T03:28:00Z", "event": "Report submitted by yassineaboukir."}, {"date_utc": "2020-04-30T11:56:00Z", "event": "Report status changed to Triaged."}, {"date_utc": "2020-05-08T09:14:00Z", "event": "Severity updated from High to Medium (6.4)."}, {"date_utc": "2020-05-08T09:16:00Z", "event": "Bounty awarded to the reporter."}, {"date_utc": "2020-05-08T09:23:00Z", "event": "Reporter confirmed the fix is working."}, {"date_utc": "2020-05-12T10:51:00Z", "event": "Report status changed to Resolved."}, {"date_utc": "2020-06-18T14:33:00Z", "event": "Report disclosed to the public."}], "summary": "The SEMrush OAuth implementation failed to properly validate the `redirect_uri` parameter. This was bypassed using an IDN (Internationalized Domain Name) homograph attack, where characters from different alphabets look identical (e.g., Latin 'e' vs. Cyrillic 'е'). This flaw allowed an attacker to leak a user's access token to a malicious domain.", "proof_of_concept": "The attacker crafts a malicious authorization URL where the `redirect_uri` points to a domain they control, but which looks identical to a legitimate Semrush domain. For example: `redirect_uri=https://oauth.sеmrush.com` (using a Cyrillic 'е'). When a user authorizes the application, their OAuth access code is sent to this malicious, look-alike domain.", "impact_assessment": {"attacker_capabilities": ["Get user ID, email, and list of projects.", "View results of the user's site audit feature.", "Increase web limit counters temporarily."], "limitations": ["The leaked token expires in 7 days.", "Web limit counters reset every 24 hours.", "The token does not allow the attacker to change, create, or delete any data or objects."]}, "resolution": "The issue was fixed by Semrush, and the fix was confirmed by the reporter. The likely fix involves normalizing Unicode characters in the `redirect_uri` to a standard form (like Punycode) before validation, preventing the system from being tricked by visually similar characters."}
{"report_id": "835437", "title": "Access Token Smuggling from my.playstation.com via Referer Header", "reporter": "nnez", "company": "PlayStation", "status": "Resolved", "vulnerability": {"weakness": "Violation of Secure Design Principles", "technique": "Chained Open Redirect", "vector": "Referer Header Leak"}, "severity": {"value": "High", "range": "7-8.9"}, "bounty": {"awarded": true, "amount_usd": 1000}, "timeline": [{"date_utc": "2020-03-31T16:45:00Z", "event": "Report submitted by nnez."}, {"date_utc": "2020-04-01T09:53:00Z", "event": "Report status changed to Triaged."}, {"date_utc": "2020-04-07T16:02:00Z", "event": "Bounty of $1,000 awarded to the reporter."}, {"date_utc": "2020-04-15T20:28:00Z", "event": "Report status initially changed to Resolved."}, {"date_utc": "2020-05-05T17:26:00Z", "event": "Report status changed to Reopened after further discussion."}, {"date_utc": "2020-05-11T17:06:00Z", "event": "Report status changed back to Resolved."}, {"date_utc": "2021-01-12T01:40:00Z", "event": "Report disclosed to the public."}], "summary": "The researcher discovered a method to steal a user's access token by chaining together two separate open redirect vulnerabilities and exploiting a URL parsing flaw. A primary redirector on my.playstation.com was tricked into redirecting to a secondary vulnerable redirector on docs.playstation.com, which would then redirect to an attacker-controlled site.", "proof_of_concept": "The core of the exploit involved manipulating URL parameters and fragments. By adding a '?' to the end of a `returnRoute` parameter inside the URL's hash fragment, the researcher tricked the JavaScript on the page into encoding the access_token (which is normally in the hash) into the query parameters of the next redirection URL. This made the token visible in the Referer header, allowing it to be stolen by the attacker's server.", "impact_assessment": {"attacker_capabilities": ["An attacker could steal a victim's access token for my.playstation.com.", "The token grants access to resources and data associated with the victim's PlayStation account, as defined by the token's scope."], "limitations": []}, "resolution": "The issue was resolved by PlayStation. The fix likely involved correcting the URL parsing logic to prevent parameters in the hash fragment from being improperly encoded and moved into the query string, and potentially adding stricter validation on the redirect endpoints."}
{"id": 265943, "title": "Stealing SSO Login Tokens from snappublisher.snapchat.com", "target": "Snapchat", "reporter": "coolboss", "severity": "High", "weakness": "Authentication Bypass", "bounty": 7500, "description": "Attacker chained multiple flaws in Snapchat's SSO and SnapPublisher to steal SSO login tokens, enabling full account takeover.", "attack_flow": ["User is logged into accounts.snapchat.com.", "Attacker forces victim via CSRF to log into attacker's SnapPublisher account.", "Victim's browser visits crafted SSO URL with referrer parameter pointing to malicious SVG hosted on snappublisher.snapchat.com Google Cloud Storage bucket.", "Snapchat SSO flow redirects with token in #hashfragment.", "Hash fragment is preserved during 302/307 redirects to attacker's controlled file.", "Malicious SVG runs JavaScript and logs the SSO token.", "Attacker uses stolen token to log into victim's SnapPublisher account."], "vulnerabilities": ["Unrestricted referrer parameter accepts any SnapPublisher URL and hash fragments.", "SSO flow allows hash fragment forwarding.", "CSRF login flaw due to missing state parameter.", "Persistent SSO tokens that do not expire after use.", "SVG upload allows XSS execution."], "impact": ["Full SnapPublisher account takeover.", "Ability to make API requests as victim."], "recommendations": ["Add state parameter to SSO login flow.", "Block hash fragments in referrer parameter.", "Restrict referrer parameter to exact safe URLs.", "Make SSO login tokens one-time use.", "Block or sanitize SVG uploads."], "timeline": {"reported": "2017-09-05T07:03:00Z", "disclosed": "2021-07-29T22:37:00Z"}, "poc": "Visit crafted URL while logged into Snapchat to leak SSO token via malicious SVG.", "references": ["https://accounts.snapchat.com/accounts/sso", "https://snappublisher.snapchat.com/sso_continue"]}
{"id": 921780, "title": "OTP Login Bypass via user_id Manipulation", "target": "Snapchat", "reporter": "korniltsev", "severity": "Critical", "weakness": "Improper Authentication", "description": "The Snapchat OTP login/logout flow trusted the user_id parameter from the client. An attacker could replace their own user_id with the victim's user_id in the logout request, receive an OTP token for the victim, and then log in as the victim.", "attack_flow": ["Attacker logs into their own Snapchat account.", "Attacker sends /scauth/otp/droid/logout request but replaces their user_id with victim's user_id.", "Server returns SUCCESS and includes an OTP token for the victim.", "Attacker sends /scauth/otp/login request with victim's username and stolen OTP token.", "Server logs attacker in as victim."], "vulnerabilities": ["No verification that user_id in logout request matches the authenticated user.", "OTP token issued without proper authorization check.", "Victim's user_id easily obtainable from friend requests."], "impact": ["Full account takeover of any Snapchat user if their user_id is known."], "recommendations": ["Verify that user_id in sensitive requests matches the authenticated session.", "Do not issue OTP tokens based solely on user_id without authentication.", "Avoid exposing user_id in publicly accessible contexts."], "timeline": {"reported": "2020-07-13T02:18:00Z", "disclosed": "2021-09-03T09:12:00Z"}, "poc": "Send /scauth/otp/droid/logout with victim's user_id to get OTP token, then /scauth/otp/login with that token to log in as victim."}
{"title": "How I Made $9,000 in One Month from Bug Bounty", "author_name": "Milad Safdari", "author_handle": "Eulex", "publication_date": "Mar 31, 2025", "platform": "Medium", "vulnerability_type": "Payment Bypass Logic Flaw", "total_bounty": 9000, "summary_of_approach": "Author focuses deeply on a single target for months, reading all related code and documentation to find overlooked flaws. This 'Deutsch it' method prioritizes quality and deep understanding over speed.", "exploit_steps": ["Initiated a purchase on the target shopping site, which redirected to the third-party PayU payment gateway.", "On the PayU gateway, the author cancelled the order.", "PayU redirected back to the target website with URL parameters indicating a cancelled transaction (e.g., status=Cancelled).", "The author intercepted this redirect and modified the URL parameters, changing the status to 'Succeed' and replacing the invalid 'payment_id' with a valid 'payment_id' from a previous, legitimate transaction.", "The author submitted the modified request to the target website.", "The target website's server processed the fraudulent 'Succeed' status and valid-looking 'payment_id', accepted the order, and issued an invoice without any payment being made."], "root_cause": "The target system's backend trusted the client-side URL parameters. It verified that the status was 'Succeed' and that the payment_id was in a valid format, but it failed to perform a server-to-server verification with PayU to confirm that the provided payment_id actually corresponded to the current, active order.", "key_takeaway": "Vulnerabilities often exist in how new technologies are implemented because developers may not read the full documentation. Deep, persistent analysis of a single target can uncover critical flaws that have been missed for years.", "full_text": "Hello everyone, it’s Milad! You may know me as Eulex. This is my first write-up in a while — sorry for the delay, but I promise to keep writing more frequently. Let’s Get Into It! 🚀 If you want to learn how to fish, read this. Otherwise… 💸 Last year, I read a few write-ups about insecure implementations that occur when businesses rush to adopt the latest technologies. As we all know, implementing security properly is always expensive and time-consuming. The golden takeaway here is that most developers don’t fully read the entire documentation when integrating new technologies. Sometimes, a single paragraph or even one sentence can make an entire system vulnerable. By focusing on these overlooked details, we can discover vulnerabilities that others have missed for years. My Approach Personally, I’m someone who narrows my focus — I can spend few months on a single domain that doesn’t even have many features. This means I read every single line of code to understand exactly how the target functions. I call this “Deutsch it” — meaning, do everything properly, no matter how long it takes, not just finishing. If you’ve lived in Germany, you know how much time things take — but when they are completed, they are done with the highest quality possible. My Process Every so often, I revisit programs I have already tested. I open my XMind (a mind-mapping tool) and go through the brain tree I built while testing. This particular program was a big public program that every hacker had probably tested, so I had to approach it differently. Since it was a shopping website with limited features, I had time to read its JavaScript code. After a month, I found some medium-severity vulnerabilities like IDOR, but my goal wasn’t just to find vulnerabilities — I wanted to test every single feature and break through to deeper issues. The Big Discovery During my testing, I came across a third-party payment service that Target used : PayU. I tried common vulnerabilities like double spending, race conditions, etc., but nothing worked. Then, I remembered my “Deutsch it” mindset. So, I started reading the entire PayU documentation and watched a few YouTube tutorials (shoutout to my Indian brothers for their great explanations). First, I drew the workflow and noted down key points. (By the way, I’m thinking about buying an iPad for this, but spending $1,000 on an iPad feels too much right now, so I stick to traditional note-taking! ) After drawing the complete workflow, I sat back and relaxed with my favorite grape juice from Lidl or Penny — they a few cents more expensive than others, but are really tasty 😁. If you curious about how they look, here you go. The Exploit Once I had the workflow mapped out, I started thinking: “What if the developer missed this step?” I love finding issues in complex implementations, because the harder something is to secure, the higher the chances of mistakes. After weeks of analyzing PayU, I tested different scenarios until I found this juicy exploit: 1. I placed some products in the cart and Target was redirected to the PayU payment gateway wich is like below. Note: Before this, I bought a cheap product to see how the system handled payments. 2. When I canceled the order, PayU redirected me back to the target website with some URL parameters like below. 3. As you see modified the status to “Succeed” and replaced the payment_id with the one from my previous successful transaction. 4. The response came back, and BOOM — I got an invoice confirming the order, without actually paying! I couldn’t believe it! After just a few minutes, I had successfully bypassed the payment system. Reporting and the $9,000 Reward I reported the bug immediately. Within a day, the issue was fixed, and I received a $3,000 bounty for it. Since I had done reverse engineering, I knew other shops were also vulnerable because their developers followed the same flawed implementation. By exploiting the same issue across different platforms, I eventually earned $9,000 in total! Cusy trick you can do “Report one bug first, wait for it to be resolved, then report others. If you submit multiple at once, they might be grouped as one!” Why Did This Vulnerability Exist for So Long? This wasn’t an easy find. It took me multiple tests, and I even spent around $1–2 per test buying products just to experiment. Many hackers likely tested this system over the past 10 years but missed the vulnerability because they didn’t persist long enough. By implementing the same setup in my localhost, I realized the issue: When an order is created, the shop waits for a response from PayU before confirming the purchase and didn’t let create another Order. If the response contains a valid payment_id with a “Succeed” status, the target system confirms the order — without verifying it internaly with PayU for which order the payment_id actually belonged to! The Lessons Learned This seemingly “easy” vulnerability took me three months to discover. But in those three months, I learned so much. Some people might say, “You should have just focused on this one vulnerability, and you could’ve found it earlier!” But remember: “You don’t know what you don’t know.” Socrates Bug bounty is all about testing thousands of features until one breaks. The Journey Continues… I’m still working on similar exploits, and there’s always more to learn. Shoutouts & Final Thoughts Big thanks to: @Voorevix (X) @MiniMjStar (X) @_0xaurora (X) Cristi Vlad And everyone who Motivated me in writing this!I truly believe that every bug bounty hunter’s hard work will pay off one day. 📢 Follow me on X and LinkedIn to stay updated! If you’ve read this far, drop 50 claps and let others see it — it’s free! 😊👏"}
{"vulnerability_name": "Cross-Site Request Forgery", "aliases": ["XSRF", "Sea Surf", "Session Riding"], "core_concept": "An attack that tricks a logged-in user's browser into submitting an unwanted, malicious request to a trusted website.", "attack_vector": "Typically delivered via social engineering, where a victim clicks a specially crafted link or visits a malicious website.", "key_flaw_exploited": "The browser automatically attaches authentication cookies to requests for a specific domain, regardless of where the request originated. The server has no way to distinguish a legitimate user's click from a forged request initiated by another site.", "primary_defense": "The Synchronizer Token Pattern.", "defense_implementation": "For every user session, generate a unique, secret, and unpredictable token (CSRF token). This token must be included in all state-changing requests (e.g., in a hidden form field or a request header). The server validates this token before executing the request.", "impact": "Unauthorized actions on behalf of the user, such as fund transfers, password changes, data theft, and account modifications.", "source_author": "Rajeev Ranjan", "source_platform": "Medium"}
{"lab_name": "Basic CSRF vulnerability with no defenses", "lab_source": "PortSwigger Web Security Academy", "vulnerability_type": "Cross-Site Request Forgery (CSRF)", "vulnerable_feature": "Email Change Functionality", "vulnerable_endpoint": "/my-account/change-email", "key_finding": "The state-changing POST request relies solely on the user's session cookie for authentication and has zero anti-CSRF mechanisms (no CSRF token, no SameSite cookie attribute checks).", "exploit_technique": "An auto-submitting HTML form hosted on an external 'exploit server' that mimics the legitimate request.", "payload_structure": "A minimal HTML page containing a hidden form. The form's 'action' attribute targets the vulnerable endpoint, and a hidden 'input' field is preset with the attacker's email. A JavaScript snippet submits this form the moment the page loads.", "solution_summary": "Capture a legitimate email-change request using a proxy to analyze its structure. Replicate this request in a CSRF PoC HTML page. Host the page on the exploit server and deliver it to the victim, whose browser will execute it automatically.", "walkthrough_author": "Deck451"}
{"cve_id": "CVE-2023-33534", "vulnerability_type": "Cross-Site Request Forgery (CSRF)", "vulnerable_product": "SZTONED Wireless Router | ZLTS10G", "vulnerable_software_version": "S10G_3.11.6", "affected_feature": "Admin Password Change", "impact": "Full Account Takeover of the router's admin panel.", "attack_summary": "An attacker crafts a malicious web page. If an administrator who is logged into the router's web panel visits this page, it forces their browser to silently send a request to the router, changing the admin password to one chosen by the attacker.", "key_technical_flaw": "The password change function relies only on the browser's session cookie for authentication and lacks any anti-CSRF token to verify user intent, making it impossible to distinguish a legitimate request from a forged one.", "remediation_summary": ["Implement anti-CSRF tokens", "Use the SameSite cookie attribute", "Require re-authentication (e.g., entering the old password) for critical actions."], "author_of_finding": "@ro0taddict"}

